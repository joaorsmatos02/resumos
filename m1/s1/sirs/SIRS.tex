\documentclass[10pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{amssymb}
\usepackage{verbatim}
\usepackage{float}
\usepackage{minitoc}
\usepackage{amsthm}
\newtheorem{definition}{Definição}
\newtheorem{theorem}{Teorema}
\usepackage{hyperref}
\title{\LARGE{Network and Computer Security } \\ \vspace{0.5cm} \normalsize{Summary}}
\date{}

\begin{document}
\maketitle
\tableofcontents

\chapter{Cryptography}
It is a widespread and dangerous belief that encrypting everything provides protection against anything. In reality, when the algorithm is known it is necessary to prevent several types of attacks, such as ciphertext-only, known-plaintext, chosen-plaintext or chosen-ciphertext. Cryptography must, then, protect the information against unauthorized insertion of information, modification of information in transit, replay of information and access to information.
\section{Cryptographic Services}
To this end, we need the following cryptographic services:
\begin{itemize}
\item Confidentiality: a service used to keep the content of the information from all, but those entities authorized to have it. Has the drawbacks of making debugging harder and may lead to information loss if the key is lost. Can be assured through symmetric of assymetric cipher.
\item Integrity: a service that detects data manipulation by unauthorized entities (not the same thing as error detection codes). An intruder should not be able to substitute a false message for a legitimate one. Can be assured through MIC or a digital signature.
\item Authenticity: a service used to ascertain the identity or the origin of a message. Can be assured through MIC or a digital signature, tough freshness requires adding a nonce to the message.
\begin{itemize}
\item Entity authentication: verify the identity of an entity
\item Data origin authentication: confirm the creator of the message
\item Non-repudiation: a service which prevents an entity from denying. Can be assured by a digital signature.
previous commitments or actions
\end{itemize}
\end{itemize}
\section{Cryptographic Building Blocks}
\subsection{Symmetric Cipher}
Uses the same key to cipher and decipher. In cryptographic function notation:
\begin{itemize}
\item $E(M,K)$: cipher message $M$ with key $K$
\item $D(C,K)$: decipher cryptogram $C$ with key $K$
\end{itemize}
\subsection{Asymmetric Cipher}
A public/private pair of keys is used ($KU/KR$). In cryptographic function notation:
\begin{itemize}
\item $AE(M, KR)$: cipher message $M$ with private key $KR$
\item $AD(C, KU)$: decipher cryptogram $C$ with public key $KU$
\end{itemize}
It is also possible to cipher with the public key and then decipher with the private key.
\subsection{Cryptographic Hash}
A cryptographic hash function does not use a key, instead receives an input message and returns a digest of the data. In cryptographic function notation:
\begin{itemize}
\item $H(M)$: hash of message $M$
\end{itemize}
The digest value is deterministic, has fixed size, a unique representation, is non-reversible and sensible to input changes.
\subsection{Composite Building Blocks}
\begin{itemize}
\item Hybrid cipher: a random symmetric key is generated and used to cipher the message. This key is then ciphered with the public key of the receiver and is sent along with the ciphered message. The receiver must decipher the symmetric key with its private key and use it do decipher the message
\item Message integrity code: the MIC is created by creating the digest of the message and ciphering the result. It can then be used to check the integrity of the message by generating a new hash and comparing to the sent one.
\item Digital signature: a digital signature is created by ciphering a digest with the private key. The receiver can then decipher with the public key and verify the identity of the sender.
\end{itemize}
\section{Symmetric Criptography}
Symmetric ciphers use a single secret key that may be shared by 2 or more communicating parties. This allows confidentiality to all those who have the key and message authentication, with good performance. The main problem lies in key distribution\\
\\
For $N$ communicating parties, $N \times (N-1) / 2$ keys are needed for them to be able to communicate 1 - 1 secretly.\\
\\
An example of a symmetric cipher is the one-time pad, where the message is XOR'd with the key. The security is based on the assumption that the key is never reused.
\subsection{Symmetric Stream Ciphers}
Symmetric stream ciphers are pratical approximations to the one-time pad. Keystreams are generated in a deterministic way from a fixed size key (approximation to real random sequence generators).
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{1.png}
\end{figure}
In this type of cipher, if the plain text is known, the keystream is exposed. The secure pseudo-random generators are sometimes based on LFSRs (Linear Feedback Shift Registers). It consists on a state machine that produces a cyclic sequence of bits:
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{2.png}
\end{figure}
\subsection{Symmetric Block Ciphers}
These are also  based on approximations, using Shannon’s notions of confusion (repeated application of a complex function to a large block) and diffusion (permutation, substitution, expansion and compression).
\subsubsection{Feistel Network}
The feistel network is a complex  function most commonly
used in block cipher algorithms. It applies a round function $F$ over multiple rounds:
\begin{itemize}
\item Each round uses a different round key ($K_i$), obtained from the key ($K$)
\item Text is split in left (L) and right (R) parts
\end{itemize}
The cipher and decipher processes are the same, with the keys used in the inverse order.
\begin{figure}[H]
\centering
\includegraphics[scale=0.4]{3.png}
\end{figure}
\subsubsection{DES}
The DES algorithm uses 64 bit blocks with 56 bit keys. It applies the feistel network algorithm on several rounds, after an initial permutation of the 64 bits, according to a fixed table.
\subsubsection{Block Cipher Modes}
When using a plaintext of different size than the block, a cipher mode must be used.
\begin{itemize}
\item $Electronic$ $Code$ $Book$ (ECB)
\begin{itemize}
\item Encryption using independent blocks
\item Weakness in reproducing patterns from the original text; identical blocks produce the same ciphertext
\end{itemize}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{4.png}
\end{figure}
\item $Cipher$ $Block$ $Chaining$ (CBC)
\begin{itemize}
\item Plaintext is XORed with the ciphertext of the previous block before encryption
\item Reduces the risk of pattern replication
\item Uses an initialization vector in the first block (necessary for decryption) and requires padding: bits to compose entire blocks of the size required by the algorithm
\end{itemize}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{5.png}
\end{figure}
\item $Output$ $Feedback$ (OFB)
\begin{itemize}
\item Retains the advantages of CFB, and the ciphertext is not used in the next block, allowing block cipher operations to be performed in advance, enabling parallel XOR as soon as the text (plaintext or ciphertext) is available
\end{itemize}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{6.png}
\end{figure}
\item $Counter$ $Mode$ (CTR)
\begin{itemize}
\item Standard cipher mode in AES
\item Uses a nonce and a counter, which must be different in each cipher operation
\end{itemize}
\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{7.png}
\end{figure}
\item $Galois$ $Counter$ $Mode$ (GCM)
\begin{figure} [H]
\centering
\includegraphics[scale=0.4]{8.png}
\end{figure}
\end{itemize}
\subsubsection{Padding}
Sometimes it may be necessary to pad the last block, when the message size is not divisible by the block length. This may be done by:
\begin{itemize}
\item Padding with zero (null) bytes, spaces (0x20), all bytes of the same value
\item Padding with random bits
\item Padding with 0x80 (1000 0000) followed by zero (null) characters
\item Padding with the PKCS\#5 scheme: Sequence of bytes, each of which equal to the number of padding bytes (e.g.   if 24 bits of padding need to be added, the padding string is "03 03 03": 3 bytes times 8 bits equals 24)
\end{itemize}
\subsubsection{AES}
AES is the current encryption standard. Supports keys of 128, 192 and 256 bits with 128 bit blocks. It runs in 10, 12 or 14 rounds, in which it substitutes bytes, shifts rows, mixes columns and adds the round key XOR state with key material)
\section{Hash Functions}
These are cryptagraphic functions, but not ciphers. They must be:
\begin{itemize}
\item Collision resistance: Computationally infeasible to find two inputs that give the same hash
\item Preimage resistance: Given a hash, it’s computationally infeasible to find an input that produces that hash
\item Seconde preimage resistant: Given a hash value and the corresponding input, it’s computationally infeasible to find a second input that generates that same hash
\end{itemize}
The most common algorithms are:
\begin{itemize}
\item MD5 (128 bits): very weak
\item SHA-1 (160 bits): weak
\item SHA-2 (256 to 512 bits)
\item SHA-3 (256 to 512 bits)
\end{itemize}
Attacks on hash functions are sometimes done by brute force ($P(collision) = 2^{m-1}$) and most often through the birthday attack ( pick $M$, $M'$, $M''$, $M'''$... and obtain hashes until any 2 are identical) ($P(collision) = 2^{m/2}$).
\subsection{Message Integrity Codes}
The objective is to detect changes to a message. It allows the checking of a message's integrity and, with freshness can provide authenticity, thus, it's sometimes called MAC.\\
\\
Under the assumption that the sender and recipient have a shared secret key $K$, the idea is to send the messgae and the MAC; if the message (or the MAC) is modified by an attacker, the recipient will be able to detect it. Attacker cannot create a valid MIC because he does not have $K$.\\
\\
Implementations of MAC could be as follows:
\begin{itemize}
\item Hash the message and encrypt the digest
\item Using a keyed-function (CMAC, usually with CBC)
\item Using a keyed-hash (HMAC)
\end{itemize}
\section{Asymmetric Ciphers}
Asymmetric cryptography uses a pair of public/private keys. It allows for confidentiality, authentication and integrity (digital signatures). Has the advantage of only needing $N$ key pairs, but the performance is much worse.\\
\\
For confidentiality, the public key is used to cipher and the private to decipher. For authentication it's the opposite.
\subsection{One-way Functions}
Also known as trapdoor functions. The idea is for the function to be easy to compute in one direction, but hard to invert. These are usually used in asymmetric cryptography.
\subsection{Algorithms}
\subsubsection{RSA}
In this algorithm, the plaintext is divided into blocks, which are treated as a number. The keys are generated as follows:
\begin{itemize}
\item Choose two prime numbers $p$ and $q$
\item Define $n = pq$ and $z = \phi(n) = (p-1)(q-1)$
\item Choose $e < n$ such that $e$ is coprime with $z$
\item Calculate $d$ such that $ed \mod z = 1$
\item The public key is $K_u = (e, n)$, and the private key is $K_r = (d, n)$
\end{itemize}
To encrypt, compute:
$$
E(K_u, m) = m^e \mod n = c
$$
And to decrypt:
$$
D(K_r, c) = c^d \mod n = m
$$
RSA is often used to produce signatures. To sign $M$ we calculate $S = (hash(M))^d \mod n$ and to verify we check $hash(M) == S^e \mod n$. Only the owner of the private key can sign, but anyone with the public key can verify the signature.
\subsubsection{ECC}
Elliptic curve cryptography offers the same security as RSA with smaller bit sizes. In this case, the "hard" problem is the elliptic curve logarithm:
\begin{itemize}
\item $Q = k \cdot P$, where $Q, P$ belong to an elliptic curve (e.g. $y^2 = x^3 - 3x + b \mod p$)
\item Easy to compute $Q$, given $k$ and $P$
\item Hard to find $k$, given $Q$ and $P$
\item $P$ is a base point (parameter of the curve)
\end{itemize}
\subsection{Digital Signatures}
Digital signatures use an asymmetric cipher and a hash function. The basic algorithm is as follows:
\begin{itemize}
\item Sign: $S(doc) = E(K_r, hash(doc))$
\item Validate: $D(K_u, S(doc)) == hash(doc)$
\end{itemize}
Today often ECDSA is adopted (with elliptic curve encryption).
\chapter{Networks}
\section{Network Models}
\subsection{OSI and Internet}
There are seven layers in the OSI model:
\begin{enumerate}
\item Physical
\item Data Link
\item Network
\item Transport
\item Session
\item Presentation
\item Application
\end{enumerate}
The network is not just computers and servers, there are also:
\begin{itemize}
\item Hubs: Send signals everywhere
\item Switches: Send frames only where they need to go
\item Routers: Look at the IP address from the incoming packet and forwards it. Have MAC address too.
\item Gateways: Access point to other networks, with possible change of addressing and networking technology.
\end{itemize}
\subsection{Address Resolution}
In layers 2 and 3, MAC and IP addresses are used, respectively. IP addresses identify the network and
the machine and MAC addresses may be converted to IPs with the ARP protocol. Some network ranges were reserved for private addressing.
\section{Network Vulnerabilities}
\subsection{Physical Layer}
\subsubsection{Hubs}
Hubs broadcast information on a shared medium, thus, are at threat of information leakage through sniffers.\\
\\
Anyone can connect to a hub even if it is physically secure.
\subsubsection{Sniffers}
Usually, network adapters operate in a non-promiscuous mode (only listen to what is sent to their MAC). Sniffers, on the other hand, read all frames, regardless of MAC.\\
\\
It is possible to indentify sniffers using tools (with several methods: latency, dns, os-specific, ...) or using the ARP method:
\begin{itemize}
\item Machines cache ARPs
\item Send a non-broadcast ARP with our correct MAC address
\item Then send a broadcast ping with the right IP but wrong MAC address
\item Only a machine which has our correct MAC address from the sniffed ARP will respond
\end{itemize}
To prevent sniffing, switches may be used instead of hubs (does not fully solve). It is also possible to prevent the effectiveness of sniffing by using one-time passwords and encryption.
\subsection{Data Link Layer}
Switches typically send frames only to the destination MAC address, and thus, reduce the sniffing problem. There are, however, some ARP vulnerabilities present:
\begin{itemize}
\item MAC flooding: attacker sends several unsolicited ARP messages, overwhelming the switch with entries. When the table is filled, some switches stop accepting connections and others revert to Hub mode
\item ARP Spoofing/Poisoning: An attacker sends a non-requested ARP message with a false IP-MAC address correspondence. ARP messages are in no way signed, so it is easy to falsify a message from any given MAC
\end{itemize}
Some preventive measures include the use of tools like $arpwatch$, to monitor the ARP to IP translation and the use of switches with fixed tables (with a cost in flexibility).
\subsection{Network Layer}
Routers support the indirect delivery of IP datagrams through the use of routing tables. Some threats in this layer include:
\begin{itemize}
\item Packet integrity: Data is not authenticated, so an attacker can change the source address of IP packets
\item Information lead and DoS: Users have little to no guarantee concerning the routing path taken by the packets. An attacker might corrupt the routing tables by sending routing-update messages and effectively hijack the route
\end{itemize}
\subsection{Transport Layer}
\subsubsection{UDP}
UDP  can be used to send and receive individual packets, without an established connection. It's just a thin addition to IP and is vulnerable to the same attacks.
\subsubsection{TCP}
TCP  can be used establish a connection to send and receive a data stream of bytes. An example of a TCP handshake:
\begin{figure}[H]
\centering
\includegraphics[scale=0.45]{9.png}
\end{figure}
There are different techniques for TCP hijecking, depending on the attacker’s capability to intercept communications:
\begin{itemize}
\item Full adversary-in-the-middle: the attacker is positioned to fully intercept the communication and  can intercept the sequence numbers and take over the connection. The tool $shijack$ is capable of doing this.
\begin{figure}[H]
\centering
\includegraphics[scale=0.45]{10.png}
\end{figure}
\item Weak adversary-in-the-middle TCP hijack: the attacker can only eavesdrop and spoof packets (cannot drop packets). Attacker must now exploit de-synchronization between hosts. Once the sender and the receiver are desynchronized, only the attacker can create data segments with correct numbers
\begin{figure}[H]
\centering
\includegraphics[scale=0.45]{11.png}
\end{figure}
The de-synchronization can be forged during the
creation of a TCP/IP connection with a reset and with false acknowledgements. It can also be done for an already established connection by sending blank data to displace sliding windows.
\item Blind TCP hijack: The attacker cannot capture return traffic from the host connection and only blindly sends malicious or manipulated packets. The attacker does not receive any confirmation of the desired effect through a packet capture and for  the attack to be successful, the attacker must guess the sequence numbers of the TCP packets
\end{itemize}
Another common TCP attacks is syn flooding. It consists of overloading a host with incomplete TCP/IP connection requests. There is no definite solution for IPv4 SYN flooding; SYN cookies may also be used to mitigate flooding:
\begin{figure}[H]
\centering
\includegraphics[scale=0.45]{12.png}
\end{figure}
Cooperation with firewalls and attack detectors is also helpful:
\begin{itemize}
\item Handshake relay: firewall stands in front of server and protects it until the handshake is complete
\item Gateway: firewall keeps the connection alive on server and terminates it if the client leaves the connection open but without traffic
\end{itemize}
\subsection{Application Layer}
\subsubsection{DNS}
DNS translates domain names to IP addresses. In 2008 the Kaminsky attack was found:
\begin{figure}[H]
\centering
\includegraphics[scale=0.45]{13.png}
\end{figure}
The attack is successful if it can guess the query ID value.\\
\\
DNSSEC is DNS with digitally signed responses. Each zone has its own key-pair for signing and public Keys are published in the DNS itself. DNSSEC provides integrity and authenticity for RRs of the signed zones.
\subsubsection{RCE}
Remote code execution is a  class of software security vulnerabilities. Most programming languages have some way to generate code in runtime and execute it, which has the potential of being abused by a malicious actor.\\
\\
To prevent code injection, one must avoid using data as code as much as possible, as well as sanitize inputs.
\section{Network Security Models}
Gatekeeper for access control:
\begin{figure}[H]
\centering
\includegraphics[scale=0.45]{14.png}
\end{figure}
Secure communication channel:
\begin{figure}[H]
\centering
\includegraphics[scale=0.45]{15.png}
\end{figure}
\section{Firewalls and Intrusion Detection Systems}
A Firewall is a means of protecting a local system or network of systems from network threats, creating a perimeter of defense.\\
\\
Incoming TCP and UDP traffic should be denied by default and malformed packets should be blocked.
\subsection{Firewall Placement}
\subsubsection{Dual-Homed Host Firewall}
This architecture uses a bastion host with 2 home networks: IN and OUT
\begin{figure}[H]
\centering
\includegraphics[scale=0.45]{16.png}
\end{figure}
It's a simple an resource-efficient topology, but has some disadvantages: compromising the machine deactivates the firewall, all the processing load is in a single machine, and public servers are within the protected network.
\subsubsection{Screened subnet}
This approach also has two internal subnets: IN and DMZ.
\begin{figure}[H]
\centering
\includegraphics[scale=0.45]{17.png}
\end{figure}
There is a lower risk regarding the public services and of the firewall being compromised. However, there is also less control over the activities going on in the DMZ machines.
\subsection{Iptables}
Iptables has 3 chains (lists of rules): input, output forward. When a packet reaches a chain, the chain’s rules decide the packet’s fate: drop or accept.
\begin{figure}[H]
\centering
\includegraphics[scale=0.45]{18.png}
\end{figure}
\subsection{Types of Firewall}
There are several types of firewall:
\begin{itemize}
\item Packet filter:
\begin{itemize}
\item Reject packets depending on the IP and transport layer headers
\item Can be stateful or stateless
\end{itemize}
\item Circuit-level gateway:
\begin{itemize}
\item Control iterations at the transport layer (typically TCP "circuit")
\item Similar to application-level gateways
\end{itemize}
\item Application-level gateway:
\begin{itemize}
\item Control iterations at the application layer
\item Protocol-specific proxy
\end{itemize}
\end{itemize}
Packet filters are faster but harder to configure and are unable to protect against "misbehaving" protocols. On the other hand, application-level gateways are slower but easier to configure, allow for more authentication mechanisms and more fine-grained control, with the disadvantage of being less adaptable to new protocols.
\subsection{Intrusion Detection Systems}
An IDS is a software that has the function to detect, identify, and respond to unauthorized or abnormal activities in the targeted system. IDS' complement firewalls and are capable of:
\begin{itemize}
\item Deep packet inspection (look at packet contents)
\item Examine correlation among multiple packets
\end{itemize}
IDS' generate alarms and, as such, are prone to generate false positives/negatives.
\subsection{IDS classification}
There are several criteria to classify IDS:
\begin{figure}[H]
\centering
\includegraphics[scale=0.45]{19.png}
\end{figure}
\begin{itemize}
\item Detection method:
\begin{itemize}
\item Misuse detection: system activity analysis in search of known attack patterns (attack signatures)
\item Anomaly Detection: matches observed behavior with a model of normal behavior
\end{itemize}
\item Data source:
\begin{itemize}
\item  Network-Based IDS: capture and do traffic analysis on network data (e.g., packets)
\item Host-Based IDS: capture and do analysis on host data
\end{itemize}
\item Reaction:
\begin{itemize}
\item Passive: only detect and report the detection results
\item Active: respond to attacks
\end{itemize}
\end{itemize}
\end{document}

%next: 5a